---
title: "Backend Overview"
description: "Technical architecture for the Vector backend."
---

Vector uses a **Django REST Framework** backend with PostgreSQL, hosted on **Railway**. Authentication is email/password with JWT tokens. Workspace isolation is enforced at the application level via permission classes and queryset scoping.

## Architecture

```
React app (Vercel) → Django REST API (Railway) → PostgreSQL (Railway)
```

The frontend calls the Django API over HTTPS. All CRUD operations go through explicit DRF viewsets. Authorization is enforced in Django via permission classes and workspace-scoped querysets.

## Tech stack

| Layer | Technology |
|---|---|
| **Framework** | Django 5.1 + Django REST Framework |
| **Database** | PostgreSQL (hosted on Railway) |
| **Auth** | Email/password login, JWT via SimpleJWT |
| **Authorization** | DRF permission classes + workspace-scoped viewset mixins |
| **Future SSO** | WorkOS (SAML, directory sync — not yet implemented) |
| **Hosting** | Railway (backend + database), Vercel (frontend) |

## Why Django

| Concern | Approach |
|---|---|
| **API** | Explicit DRF viewsets and serializers — full control over endpoints |
| **Auth** | SimpleJWT for token management, custom User model with email login |
| **Workspace isolation** | `WorkspaceScopedViewSetMixin` auto-filters querysets by workspace |
| **Permissions** | DRF permission classes (`HasWorkspaceAccess`) checked on every request |
| **Admin** | Built-in Django admin for workspace and user management |
| **Migrations** | Django's migration framework — version-controlled, reversible |
| **Future SSO** | WorkOS integration for enterprise SAML when needed |

## Project structure

```
vector-backend/
├── vector/                     # Django project package
│   ├── settings.py
│   ├── urls.py
│   ├── wsgi.py
│   └── asgi.py
├── authentication/             # Auth app
│   ├── models.py               # User, Workspace, WorkspaceMember
│   ├── serializers.py
│   ├── views.py                # login, logout, me, workspaces, switch
│   ├── urls.py
│   └── admin.py
└── core/                       # Shared utilities
    ├── permissions.py           # HasWorkspaceAccess, IsSuperUser
    ├── viewsets.py              # WorkspaceScopedViewSetMixin
    ├── managers.py              # WorkspaceScopedManager
    └── models.py                # WorkspaceScopedQuerySet
```

Future domain apps (e.g., `circles`, `decisions`, `commitments`) will follow the same pattern — each app gets its own models, serializers, viewsets, and URLs, all workspace-scoped via the core utilities.

## Frontend integration

The React app authenticates via JWT and includes the token in every request:

```typescript
// Login
const response = await fetch('/auth/v1/login/', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, password }),
});
const { access, refresh, workspaces, active_workspace } = await response.json();

// Authenticated requests
const decisions = await fetch(`/api/v1/${workspaceSlug}/decisions/`, {
  headers: { Authorization: `Bearer ${access}` },
});
```

## Sections

<CardGroup cols={2}>
  <Card title="Auth & Multi-Tenancy" icon="lock" href="/backend/auth-and-tenancy">
    JWT authentication, workspace isolation, and the WorkOS roadmap.
  </Card>
  <Card title="Auth Lifecycle" icon="arrows-rotate" href="/backend/auth-lifecycle">
    The complete login, session, and token lifecycle from first visit to logout.
  </Card>
  <Card title="API Reference" icon="code" href="/backend/api">
    REST API conventions, auth endpoints, and planned domain endpoints.
  </Card>
  <Card title="Permissions" icon="user-shield" href="/backend/permissions">
    How permissions are derived from data relationships and enforced in Django.
  </Card>
</CardGroup>
