---
title: "Background Jobs & Triggers"
description: "Django management commands, signals, and Postgres triggers for custom logic."
---

Most of Vector's behavior is handled by DRF viewsets and serializers. The items below cover custom logic that runs outside normal request handling.

## Postgres triggers

Postgres triggers handle logic that must be enforced regardless of whether the change comes from Django or a direct database operation.

### Auto-generate session numbers

Each circle has its own independent session numbering starting at 1.

```sql
CREATE OR REPLACE FUNCTION generate_session_number()
RETURNS trigger AS $$
BEGIN
  NEW.number := COALESCE(
    (SELECT MAX(number) FROM sessions WHERE circle_id = NEW.circle_id),
    0
  ) + 1;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_session_number
  BEFORE INSERT ON sessions
  FOR EACH ROW EXECUTE FUNCTION generate_session_number();
```

### Update `updated_at` timestamps

Shared trigger applied to all tables with an `updated_at` column. This acts as a safeguard alongside Django's `auto_now=True`.

```sql
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

Applied to: `workspaces`, `persons`, `circles`, `sessions`, `initiatives`, `projects`, `decisions`, `commitments`, `project_updates`.

## Django model validation

Validation that was previously handled by Postgres triggers is now enforced in Django serializers and model `clean()` methods. This keeps validation logic in one place (Python) and provides better error messages to the API consumer.

### Validate sponsor is circle member

Ensures the decision sponsor belongs to the decision's circle. Validated when `sponsor_person_id` is set (it's nullable — set when the decision is Scheduled).

```python
# In DecisionSerializer or Decision.clean()
def validate_sponsor(self, decision):
    if decision.sponsor_person_id and not CircleMember.objects.filter(
        circle_id=decision.circle_id,
        person_id=decision.sponsor_person_id
    ).exists():
        raise ValidationError("Sponsor must be a member of the decision's circle")
```

### Validate commitment owner is circle member

Ensures the commitment owner belongs to the review circle.

```python
# In CommitmentSerializer or Commitment.clean()
def validate_owner(self, commitment):
    if not CircleMember.objects.filter(
        circle_id=commitment.review_circle_id,
        person_id=commitment.owner_person_id
    ).exists():
        raise ValidationError("Commitment owner must be a member of the review circle")
```

## Activity event creation

Activity events are created via Django signals or explicit calls in viewset `perform_create`/`perform_update` methods. A helper function handles the INSERT into `activity_events`.

```python
# core/activity.py
def emit_activity_event(workspace_id, actor_person_id, entity_type, entity_id, action, metadata=None):
    ActivityEvent.objects.create(
        workspace_id=workspace_id,
        actor_person_id=actor_person_id,
        entity_type=entity_type,
        entity_id=entity_id,
        action=action,
        metadata=metadata or {},
    )
```

### When to use signals vs. explicit calls

| Use case | Approach |
|---|---|
| Status changes, field updates | Explicit call in `perform_update()` — can compare old vs. new values |
| Entity creation | Explicit call in `perform_create()` — actor is `request.user` |
| Cascading events (e.g., circle membership changes) | Django `post_save`/`post_delete` signals |

See the [event catalog](/domain/schema#event-catalog) for the full list of actions and metadata.

## Planned management commands

Django management commands handle scheduled and batch operations. These can be triggered via Railway cron jobs.

### Auto-roll commitments

A scheduled command that runs daily and rolls commitments whose due date has passed:

```python
# commitments/management/commands/auto_roll_commitments.py
class Command(BaseCommand):
    help = "Roll overdue commitments"

    def handle(self, *args, **options):
        today = date.today()
        rolled = Commitment.objects.filter(
            status__in=["Active", "At risk"],
            due__lt=today,
        ).update(status="Rolled")

        self.stdout.write(f"Rolled {rolled} overdue commitments")
```

Triggered via a Railway cron job running daily:

```bash
python manage.py auto_roll_commitments
```

### Notification dispatch

A management command (or Celery task, if needed) that sends notifications when specific events occur — e.g., a commitment is assigned, a decision is scheduled, or a session is marked complete.

## Migration strategy

All database changes are managed via Django migrations:

```bash
# Create a new migration after model changes
python manage.py makemigrations

# Apply migrations
python manage.py migrate

# Create a custom data migration
python manage.py makemigrations --empty app_name -n description
```

Migration files live in each app's `migrations/` directory and are version-controlled in Git. Railway runs `python manage.py migrate` automatically on deploy.
