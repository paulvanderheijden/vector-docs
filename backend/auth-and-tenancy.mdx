---
title: "Auth & Multi-Tenancy"
description: "How Vector implements authentication and workspace isolation with Supabase."
---

Vector uses Supabase Auth for authentication and Row-Level Security (RLS) for workspace isolation. Auth is at the user level; workspace access is determined by membership.

## Authentication

### How it works

Supabase Auth handles the entire auth lifecycle — sign up, sign in, token management, and session refresh. No custom auth code needed.

```typescript
// Sign in
const { data, error } = await supabase.auth.signInWithPassword({
  email: 'matt@mews.com',
  password: '...'
});

// Session is automatically managed — tokens refresh transparently
// Every subsequent supabase call includes the JWT automatically
```

### Auth flow

1. User signs in via Supabase Auth (email/password or OAuth)
2. Supabase returns a JWT containing the user's `auth.uid()`
3. The Supabase JS client stores the session and auto-refreshes tokens
4. Every database query includes the JWT — RLS policies use `auth.uid()` to determine access

### Token management

| Setting | Value |
|---|---|
| Access token | Auto-managed by Supabase JS client |
| Refresh | Automatic — no manual refresh logic needed |
| Storage | Handled by `@supabase/supabase-js` (localStorage by default) |
| Session detection | `supabase.auth.onAuthStateChange()` listener |

<Note>
  Unlike the cobber-alpha approach (manual JWT with `_retry` flags and interceptors), Supabase handles token refresh transparently. The entire token lifecycle is managed by the client library.
</Note>

### User creation

When a user signs up via Supabase Auth, a trigger automatically creates a row in the `persons` table:

```sql
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO persons (id, email, name, initials)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'name', ''),
    COALESCE(NEW.raw_user_meta_data->>'initials', '')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();
```

The `persons.id` matches `auth.users.id` — this is how RLS policies map authenticated users to workspace membership.

## Multi-tenancy

### Workspace isolation via RLS

Every workspace-scoped table has a `workspace_id` column. RLS policies ensure a user can only access rows in workspaces they belong to:

```sql
-- Core policy pattern: check workspace membership
CREATE POLICY "workspace_isolation" ON decisions
  FOR ALL
  USING (
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE person_id = auth.uid()
    )
  );
```

This is enforced at the **database level** — even if the frontend code has a bug, Postgres itself rejects cross-tenant queries. This is stronger than the app-level filtering used in cobber-alpha.

### Workspace selection flow

1. User signs in
2. Frontend queries `workspace_members` to get the user's workspaces
3. User selects a workspace (or is redirected to their `last_active_workspace`)
4. Frontend stores the active `workspace_id` in state
5. All subsequent queries include `.eq('workspace_id', workspaceId)`
6. RLS double-checks that the user actually belongs to this workspace

```typescript
// Get user's workspaces
const { data: memberships } = await supabase
  .from('workspace_members')
  .select('workspace:workspaces(*), role')
  .eq('person_id', user.id);

// All queries scoped to the selected workspace
const { data: circles } = await supabase
  .from('circles')
  .select('*, members:circle_members(person:persons(*))')
  .eq('workspace_id', activeWorkspaceId);
```

### Why RLS over app-level filtering

| Concern | App-level (cobber) | RLS (Vector) |
|---|---|---|
| **Where isolation is enforced** | Python mixin in every viewset | Postgres policy on every table |
| **What happens if you forget** | Data leak — wrong tenant sees data | Impossible — Postgres blocks it |
| **Debugging** | Inspect Python code | `SELECT * FROM pg_policies` |
| **Performance** | Extra WHERE clause per query | Same, but enforced by the planner |

### Lessons from cobber-alpha

These patterns were painful to get right in cobber-alpha. Supabase eliminates most of them:

1. **Mixin-based scoping** → replaced by RLS. No mixin to forget to apply.
2. **Manual token refresh with `_retry` flag** → replaced by Supabase's auto-refresh.
3. **Graceful login fallbacks** → Supabase Auth handles errors internally.
4. **`last_active_workspace` storage** → still needed, stored in `persons` table.
5. **Double-check access (permission + queryset)** → RLS is the single source of truth.

The one pattern that carries over: **workspace slug in the URL**. The frontend still uses `/{workspaceSlug}/...` routes for navigation — this is a UX pattern, not a security mechanism. Security is enforced by RLS using `workspace_id`, not the slug.
