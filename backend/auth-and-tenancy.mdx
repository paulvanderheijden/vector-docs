---
title: "Auth & Multi-Tenancy"
description: "How Vector implements authentication and workspace isolation with Django."
---

Vector uses Django REST Framework with SimpleJWT for authentication and application-level scoping for workspace isolation. Auth is at the user level; workspace access is determined by membership.

## Authentication

### How it works

The custom `User` model uses **email as the login identifier** — there is no username field. Authentication is handled via JWT tokens issued by SimpleJWT.

```
POST /auth/v1/login/
{
  "email": "matt@mews.com",
  "password": "..."
}

→ 200 OK
{
  "access": "eyJ...",
  "refresh": "eyJ...",
  "workspaces": [
    { "slug": "mews", "name": "Mews", "role": "admin", "created_at": "..." }
  ],
  "active_workspace": "mews"
}
```

### Auth flow

1. User signs in with email and password via `POST /auth/v1/login/`
2. Django authenticates and returns JWT access + refresh tokens, plus the user's workspaces
3. The frontend stores tokens and includes `Authorization: Bearer <access>` on every request
4. SimpleJWT validates the token on each request — DRF permission classes check workspace access
5. When the access token expires, the frontend refreshes it via `POST /auth/v1/token/refresh/`

### Token management

| Setting | Value |
|---|---|
| Access token lifetime | 30 minutes |
| Refresh token lifetime | 7 days |
| Token rotation | Disabled |
| Blacklisting | Enabled (on logout) |
| Auth header | `Authorization: Bearer <token>` |

### Auth endpoints

| Method | Endpoint | Description |
|---|---|---|
| `POST` | `/auth/v1/login/` | Email + password → JWT tokens + workspaces |
| `POST` | `/auth/v1/logout/` | Blacklist refresh token |
| `GET` | `/auth/v1/me/` | Current user info |
| `GET` | `/auth/v1/workspaces/` | User's workspaces with roles |
| `POST` | `/auth/v1/workspaces/switch/` | Set active workspace |
| `POST` | `/auth/v1/token/` | SimpleJWT token obtain (standard) |
| `POST` | `/auth/v1/token/refresh/` | SimpleJWT token refresh |

### User model

The custom `User` extends `AbstractUser` with `username = None` and `USERNAME_FIELD = "email"`. Profile fields (`job_title`, `avatar_url`) are stored directly on the User model — there is no separate Person table.

```python
class User(AbstractUser):
    username = None
    email = models.EmailField(unique=True)
    job_title = models.CharField(max_length=255, blank=True, default="")
    avatar_url = models.URLField(max_length=500, blank=True, default="")
    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []

    last_active_workspace = models.ForeignKey(
        "Workspace", on_delete=models.SET_NULL, null=True, blank=True
    )

    @property
    def name(self):
        return f"{self.first_name} {self.last_name}".strip() or self.email

    @property
    def initials(self):
        if self.first_name and self.last_name:
            return f"{self.first_name[0]}{self.last_name[0]}".upper()
        return self.email[0].upper()
```

### Future: WorkOS for enterprise SSO

WorkOS will be added when enterprise customers need SAML/SSO. The migration path:

1. **Current** — email/password with JWT (SimpleJWT)
2. **Future** — WorkOS AuthKit for SAML, directory sync, and MFA

WorkOS provides a clean upgrade path because it handles the SSO handshake and returns a user identity that can be mapped to the existing `User` model. The JWT flow stays the same — WorkOS just becomes an additional authentication backend alongside email/password.

## Multi-tenancy

### Workspace isolation via Django

Every workspace-scoped API endpoint includes the workspace slug in the URL path:

```
GET  /api/v1/workspaces/{workspace_slug}/decisions/
POST /api/v1/workspaces/{workspace_slug}/decisions/
GET  /api/v1/workspaces/{workspace_slug}/decisions/{id}/
```

The `WorkspaceScopedViewSetMixin` handles both access control and data scoping:

1. **`get_workspace()`** — resolves the workspace slug from the URL and verifies the authenticated user has an active `WorkspaceMember` record. Returns 404 if not a member.
2. **`get_queryset()`** — auto-filters to only return rows belonging to the resolved workspace.
3. **`perform_create()`** — auto-sets the workspace FK on create.

```python
class DecisionViewSet(WorkspaceScopedViewSetMixin, viewsets.ModelViewSet):
    queryset = Decision.objects.all()
    serializer_class = DecisionSerializer
    lookup_field = "slug"
```

This ensures that every viewset inheriting the mixin can only see and create data within the authenticated user's workspace — no cross-tenant leaks.

A standalone `HasWorkspaceAccess` permission class also exists for use cases outside the mixin.

### Workspace selection flow

1. User signs in → response includes their workspaces
2. Frontend stores the active workspace slug in state
3. User selects a workspace (or is redirected to their `last_active_workspace`)
4. All subsequent API calls include the workspace slug in the URL
5. `HasWorkspaceAccess` rejects requests where the user isn't a member
6. `WorkspaceScopedViewSetMixin` filters querysets to the workspace

```
POST /auth/v1/workspaces/switch/
{ "workspace_slug": "mews" }

→ 200 OK
{ "active_workspace": "mews", "name": "Mews" }
```

### WorkspaceMember model

```python
class WorkspaceMember(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    workspace = models.ForeignKey(Workspace, on_delete=models.CASCADE)
    role = models.CharField(choices=[("admin", "Admin"), ("member", "Member")])
    is_active = models.BooleanField(default=True)  # Soft-disable

    class Meta:
        unique_together = ("user", "workspace")
```

| Role | Description |
|---|---|
| `admin` | Can manage workspace settings, invite/remove people, create/edit circles |
| `member` | Can view and create entities within the workspace |

| is_active | Description |
|---|---|
| `True` | Normal access |
| `False` | Soft-disabled — historical references preserved, no active access |

### Queryset-level scoping

For cases outside viewsets (e.g., management commands, signals), the `WorkspaceScopedManager` provides `.for_user()` filtering:

```python
class WorkspaceScopedQuerySet(models.QuerySet):
    def for_user(self, user):
        if user.is_superuser:
            return self
        if user.is_authenticated:
            workspace_ids = WorkspaceMember.objects.filter(
                user=user, is_active=True
            ).values_list("workspace_id", flat=True)
            return self.filter(workspace_id__in=workspace_ids)
        return self.none()
```

### Workspace slug in URLs

The workspace slug appears in all domain API URLs. This is both a UX pattern (readable URLs) and a security mechanism — the `WorkspaceScopedViewSetMixin` validates the slug against the user's memberships on every request.

```
/api/v1/workspaces/mews/decisions/      → decisions in the "mews" workspace
/api/v1/workspaces/mews/circles/        → circles in the "mews" workspace
/api/v1/workspaces/mews/commitments/    → commitments in the "mews" workspace
```
